# Macros

Use macros to generate code at compile time.

Macros transform your source code when you compile it,
letting you avoid writing repetitive code by hand.
During compilation,
Swift expands any macros in your code before building your code as usual.

![A diagram showing an overview of macro expansion.  On the left, a stylized representation of Swift code.  On the right, the same code with several lines added by the macro.](macro-expansion)

Expanding a macro is always an additive operation:
Macros add new code,
but they never delete or modify existing code.

Both the input to a macro and the output of macro expansion
are checked to ensure they're syntactically valid Swift code.
Likewise, the values you pass to a macro
and the values in code generated by a macro
are checked to ensure they have the correct types.
In addition,
if the macro's implementation encounters an error when expanding that macro,
the compiler treats this as a compilation error.
These guarantees make it easier to reason about code that uses macros,
and they make it easier to identify issues
like using a macro incorrectly
or a macro implementation that has a bug.

Swift has two kinds of macros:

- *Freestanding macros* appear on their own,
  without being attached to a declaration.

- *Attached macros* modify the declaration that they're attached to.

You call attached and freestanding macros slightly differently,
but they both follow the same model for macro expansion,
and you implement them both using the same approach.
The following sections describe both kinds of macros in more detail.

## Freestanding Macros

To call a freestanding macro,
you write a number sign (`#`) before its name,
and you write any arguments to the macro in parentheses after its name.
For example:

```swift
func myFunction() {
    print("Currently running \(#function)")
    #warning("Something's wrong")
}
```

In the first line,
`#function` calls the [`function()`][] macro from the Swift standard library.
When you compile this code,
Swift calls that macro's implementation,
which replaces `#function` with the name of the current function.
When you run this code and call `myFunction()`,
it prints "Currently running myFunction()".
In the second line,
`#warning` calls the [`warning(_:)`][] macro from the Swift standard library
to produce a custom compile-time warning.

[`function()`]: https://developer.apple.com/documentation/swift/function()
[`warning(_:)`]: https://developer.apple.com/documentation/swift/warning(_:)

Freestanding macros can produce a value, like `#function` does,
or they can perform an action at compile time, like `#warning` does.
<!-- SE-0397: or they can generate new declarations.  -->

## Attached Macros

To call an attached macro,
you write an at sign (`@`) before its name,
and you write any arguments to the macro in parentheses after its name.

Attached macros modify the declaration that they're attached to.
They add code to that declaration,
like defining a new method or adding conformance to a protocol.

For example, consider the following code
that doesn't use macros:

```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

In this code,
each of the options in the `SundaeToppings` option set
includes a call to the initializer,
which is repetitive and manual.
It would be easy to make a mistake when adding a new option,
like typing the wrong number at the end of the line.

Here's a version of this code that uses a macro instead:

```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

This version of `SundaeToppings` calls an `@OptionSet` macro.
The macro reads the list of cases in the private enumeration,
generates the list of constants for each option,
and adds a conformance to the [`OptionSet`][] protocol.

[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset

<!--
When the @OptionSet macro comes back, change both links back:

[`@OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.macro
[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.protocol
-->


For comparison,
here's what the expanded version of the `@OptionSet` macro looks like.
You don't write this code,
and you would see it only if you specifically asked Swift
to show the macro's expansion.

```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue
    init() { self.rawValue = 0 }
    init(rawValue: RawValue) { self.rawValue = rawValue }
    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}
extension SundaeToppings: OptionSet { }
```

All of the code after the private enumeration
comes from the `@OptionSet` macro.
The version of `SundaeToppings`
that uses a macro to generate all of the static variables
is easier to read and easier to maintain
than the manually coded version, earlier.

## Macro Declarations

In most Swift code,
when you implement a symbol, like a function or type,
there's no separate declaration.
However, for macros, the declaration and implementation are separate.
A macro's declaration contains its name,
the parameters it takes,
where it can be used,
and what kind of code it generates.
A macro's implementation contains the code
that expands the macro by generating Swift code.

You introduce a macro declaration with the `macro` keyword.
For example,
here's part of the declaration for
the `@OptionSet` macro used in the previous example:

```swift
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The first line
specifies the macro's name and its arguments ---
the name is `OptionSet`, and it doesn't take any arguments.
The second line
uses the [`externalMacro(module:type:)`][] macro from the Swift standard library
to tell Swift where the macro's implementation is located.
In this case,
the `SwiftMacros` module
contains a type named `OptionSetMacro`,
which implements the `@OptionSet` macro.

[`externalMacro(module:type:)`]: https://developer.apple.com/documentation/swift/externalmacro(module:type:)

Because `OptionSet` is an attached macro,
its name uses upper camel case,
like the names for structures and classes.
Freestanding macros have lower camel case names,
like the names for variables and functions.

> Note:
> Macros are always declared as `public`.
> Because the code that declares a macro
> is in a different module from code that uses that macro,
> there isn't anywhere you could apply a nonpublic macro.

A macro declaration defines the macro's *roles* ---
the places in source code where that macro can be called,
and the kinds of code the macro can generate.
Every macro has one or more roles,
which you write as part of the attributes
at the beginning of the macro declaration.
Here's a bit more of the declaration for `@OptionSet`,
including the attributes for its roles:

```swift
@attached(member)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

The `@attached` attribute appears twice in this declaration,
once for each macro role.
The first use, `@attached(member)`, indicates that the macro
adds new members to the type you apply it to.
The `@OptionSet` macro adds an `init(rawValue:)` initializer
that's required by the `OptionSet` protocol,
as well as some additional members.
The second use, `@attached(extension, conformances: OptionSet)`,
tells you that `@OptionSet`
adds conformance to the `OptionSet` protocol.
The `@OptionSet` macro
extends the type that you apply the macro to,
to add conformance to the `OptionSet` protocol.

For a freestanding macro,
you write the `@freestanding` attribute to specify its role:

```
@freestanding(expression)
public macro line<T: ExpressibleByIntegerLiteral>() -> T =
        /* ... location of the macro implementation... */
```

<!--
Elided the implementation of #line above
because it's a compiler built-in:

public macro line<T: ExpressibleByIntegerLiteral>() -> T = Builtin.LineMacro
-->

The `#line` macro above has the `expression` role.
An expression macro produces a value,
or performs a compile-time action like generating a warning.

In addition to the macro's role,
a macro's declaration provides information about
the names of the symbols that the macro generates.
When a macro declaration provides a list of names,
it's guaranteed to produce only declarations that use those names,
which helps you understand and debug the generated code.
Here's the full declaration of `@OptionSet`:

```swift
@attached(member, names: named(RawValue), named(rawValue),
        named(`init`), arbitrary)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() =
        #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

In the declaration above,
the `@attached(member)` macro includes arguments after the `names:` label
for each of the symbols that the `@OptionSet` macro generates.
The macro adds declarations for symbols named
`RawValue`, `rawValue`, and `init` ---
because those names are known ahead of time,
the macro declaration lists them explicitly.

The macro declaration also includes `arbitrary` after the list of names,
allowing the macro to generate declarations
whose names aren't known until you use the macro.
For example,
when the `@OptionSet` macro is applied to the `SundaeToppings` above,
it generates type properties that correspond to the enumeration cases,
`nuts`, `cherry`, and `fudge`.

For more information,
including a full list of macro roles,
see <doc:Attributes#attached> and <doc:Attributes#freestanding>
in <doc:Attributes>.

## Macro Expansion

When building Swift code that uses macros,
the compiler calls the macros' implementation to expand them.

![Diagram showing the four steps of expanding macros.  The input is Swift source code.  This becomes a tree, representing the code's structure.  The macro implementation adds branches to the tree.  The result is Swift source with additional code.](macro-expansion-full)

Specifically, Swift expands macros in the following way:

1. The compiler reads the code,
   creating an in-memory representation of the syntax.

1. The compiler sends part of the in-memory representation
   to the macro implementation,
   which expands the macro.

1. The compiler replaces the macro call with its expanded form.

1. The compiler continues with compilation,
   using the expanded source code.

To go through the specific steps, consider the following:

```
let magicNumber = #fourCharacterCode("ABCD")
```

The `#fourCharacterCode` macro takes a string that's four characters long
and returns an unsigned 32-bit integer
that corresponds to the ASCII values in the string joined together.
Some file formats use integers like this to identify data
because they're compact but still readable in a debugger.
The <doc:Macros#Implementing-a-Macro> section below
shows how to implement this macro.

To expand the macros in the code above,
the compiler reads the Swift file
and creates an in-memory representation of that code
known as an *abstract syntax tree*, or AST.
The AST makes the code's structure explicit,
which makes it easier to write code that interacts with that structure ---
like a compiler or a macro implementation.
Here's a representation of the AST for the code above,
slightly simplified by omitting some extra detail:

![A tree diagram, with a constant as the root element.  The constant has a name, magic number, and a value.  The constant's value is a macro call.  The macro call has a name, fourCharacterCode, and arguments.  The argument is a string literal, ABCD.](macro-ast-original)

The diagram above shows how the structure of this code
is represented in memory.
Each element in the AST
corresponds to a part of the source code.
The "Constant declaration" AST element
has two child elements under it,
which represent the two parts of a constant declaration:
its name and its value.
The "Macro call" element has child elements
that represent the macro's name
and the list of arguments being passed to the macro.

As part of constructing this AST,
the compiler checks that the source code is valid Swift.
For example, `#fourCharacterCode` takes a single argument,
which must be a string.
If you tried to pass an integer argument,
or forgot the quotation mark (`"`) at the end of the string literal,
you'd get an error at this point in the process.

The compiler finds the places in the code where you call a macro,
and loads the external binary that implements those macros.
For each macro call,
the compiler passes part of the AST to that macro's implementation.
Here's a representation of that partial AST:

![A tree diagram, with a macro call as the root element.  The macro call has a name, fourCharacterCode, and arguments.  The argument is a string literal, ABCD.](macro-ast-input)

The implementation of the `#fourCharacterCode` macro
reads this partial AST as its input when expanding the macro.
A macro's implementation
operates only on the partial AST that it receives as its input,
meaning a macro always expands the same way
regardless of what code comes before and after it.
This limitation helps make macro expansion easier to understand,
and helps your code build faster
because Swift can avoid expanding macros that haven't changed.
<!-- TODO TR: Confirm -->
Swift helps macro authors avoid accidentally reading other input
by restricting the code that implements macros:

- The AST passed to a macro implementation
  contains only the AST elements that represent the macro,
  not any of the code that comes before or after it.

- The macro implementation runs in a sandboxed environment
  that prevents it from accessing the file system or the network.

In addition to these safeguards,
the macro's author is responsible for not reading or modifying anything
outside of the macro's inputs.
For example, a macro's expansion must not depend on the current time of day.

The implementation of `#fourCharacterCode`
generates a new AST containing the expanded code.
Here's what that code returns to the compiler:

![A tree diagram with the integer literal 1145258561 of type UInt32.](macro-ast-output)

When the compiler receives this expansion,
it replaces the AST element that contains the macro call
with the element that contains the macro's expansion.
After macro expansion,
the compiler checks again to ensure
the program is still syntactically valid Swift
and all the types are correct.
That produces a final AST that can be compiled as usual:

![A tree diagram, with a constant as the root element.  The constant has a name, magic number, and a value.  The constant's value is the integer literal 1145258561 of type UInt32.](macro-ast-result)

This AST corresponds to Swift code like this:

```
let magicNumber = 1145258561 as UInt32
```

In this example, the input source code has only one macro,
but a real program could have several instances of the same macro
and several calls to different macros.
The compiler expands macros one at a time.

If one macro appears inside another,
the outer macro is expanded first ---
this lets the outer macro modify the inner macro before it's expanded.

<!-- OUTLINE

- TR: Is there any limit to nesting?
  TR: Is it valid to nest like this -- if so, anything to note about it?

  ```
  let something = #someMacro {
      struct A { }
      @someMacro struct B { }
  }
  ```

- Macro recursion is limited.
  One macro can call another,
  but a given macro can't directly or indirectly call itself.
  The result of macro expansion can include other macros,
  but it can't include a macro that uses this macro in its expansion
  or declare a new macro.
  (TR: Likely need to iterate on details here)
-->

## Implementing a Macro

To implement a macro, you make two components:
A type that performs the macro expansion,
and a library that declares the macro to expose it as API.
These parts are built separately from code that uses the macro,
even if you're developing the macro and its clients together,
because the macro implementation runs
as part of building the macro's clients.

To create a new macro using Swift Package Manager,
run `swift package init --type macro` ---
this creates several files,
including a template for a macro implementation and declaration.

To add macros to an existing project,
edit the beginning of your `Package.swift` file as follows:

- Set a Swift tools version of 5.9 or later in the `swift-tools-version` comment.
- Import the `CompilerPluginSupport` module.
- Include macOS 10.15 as a minimum deployment target in the `platforms` list.

The code below shows the beginning of an example `Package.swift` file.

```swift
// swift-tools-version: 5.9

import PackageDescription
import CompilerPluginSupport

let package = Package(
    name: "MyPackage",
    platforms: [ .iOS(.v17), .macOS(.v13)],
    // ...
)
```

Next, add a target for the macro implementation
and a target for the macro library
to your existing `Package.swift` file.
For example,
you can add something like the following,
changing the names to match your project:

```swift
targets: [
    // Macro implementation that performs the source transformations.
    .macro(
        name: "MyProjectMacros",
        dependencies: [
            .product(name: "SwiftSyntaxMacros", package: "swift-syntax"),
            .product(name: "SwiftCompilerPlugin", package: "swift-syntax")
        ]
    ),

    // Library that exposes a macro as part of its API.
    .target(name: "MyProject", dependencies: ["MyProjectMacros"]),
]
```

The code above defines two targets:
`MyProjectMacros` contains the implementation of the macros,
and `MyProject` makes those macros available.

The implementation of a macro
uses the [SwiftSyntax][] module to interact with Swift code
in a structured way, using an AST.
If you created a new macro package with Swift Package Manager,
the generated `Package.swift` file
automatically includes a dependency on SwiftSyntax.
If you're adding macros to an existing project,
add a dependency on SwiftSyntax in your `Package.swift` file:

[SwiftSyntax]: http://github.com/apple/swift-syntax/

```swift
dependencies: [
    .package(url: "https://github.com/apple/swift-syntax", from: "509.0.0")
],
```

Depending on your macro's role,
there's a corresponding protocol from SwiftSyntax
that the macro implementation conforms to.
For example,
consider `#fourCharacterCode` from the previous section.
Here's a structure that implements that macro:

```swift
import SwiftSyntax
import SwiftSyntaxMacros

public struct FourCharacterCode: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) throws -> ExprSyntax {
        guard let argument = node.argumentList.first?.expression,
              let segments = argument.as(StringLiteralExprSyntax.self)?.segments,
              segments.count == 1,
              case .stringSegment(let literalSegment)? = segments.first
        else {
            throw CustomError.message("Need a static string")
        }

        let string = literalSegment.content.text
        guard let result = fourCharacterCode(for: string) else {
            throw CustomError.message("Invalid four-character code")
        }

        return "\(raw: result) as UInt32"
    }
}

private func fourCharacterCode(for characters: String) -> UInt32? {
    guard characters.count == 4 else { return nil }

    var result: UInt32 = 0
    for character in characters {
        result = result << 8
        guard let asciiValue = character.asciiValue else { return nil }
        result += UInt32(asciiValue)
    }
    return result
}
enum CustomError: Error { case message(String) }
```

If you're adding this macro to an existing Swift Package Manager project,
add a type that acts as the entry point for the macro target
and lists the macros that the target defines:

```swift
import SwiftCompilerPlugin

@main
struct MyProjectMacros: CompilerPlugin {
    var providingMacros: [Macro.Type] = [FourCharacterCode.self]
}
```

The `#fourCharacterCode` macro
is a freestanding macro that produces an expression,
so the `FourCharacterCode` type that implements it
conforms to the `ExpressionMacro` protocol.
The `ExpressionMacro` protocol has one requirement,
an `expansion(of:in:)` method that expands the AST.
For the list of macro roles and their corresponding SwiftSyntax protocols,
see <doc:Attributes#attached> and <doc:Attributes#freestanding>
in <doc:Attributes>.

To expand the `#fourCharacterCode` macro,
Swift sends the AST for the code that uses this macro
to the library that contains the macro implementation.
Inside the library, Swift calls `FourCharacterCode.expansion(of:in:)`,
passing in the AST and the context as arguments to the method.
The implementation of `expansion(of:in:)`
finds the string that was passed as an argument to `#fourCharacterCode`
and calculates the corresponding 32-bit unsigned integer literal value.

In the example above,
the first `guard` block extracts the string literal from the AST,
assigning that AST element to `literalSegment`.
The second `guard` block
calls the private `fourCharacterCode(for:)` function.
Both of these blocks throw an error if the macro is used incorrectly ---
the error message becomes a compiler error
at the malformed call site.
For example,
if you try to call the macro as `#fourCharacterCode("AB" + "CD")`
the compiler shows the error "Need a static string".

The `expansion(of:in:)` method returns an instance of `ExprSyntax`,
a type from SwiftSyntax that represents an expression in an AST.
Because this type conforms to the `StringLiteralConvertible` protocol,
the macro implementation uses a string literal
as a lightweight syntax to create its result.
All of the SwiftSyntax types that you return from a macro implementation
conform to `StringLiteralConvertible`,
so you can use this approach when implementing any kind of macro.

<!-- TODO contrast the `\(raw:)` and non-raw version.  -->

<!--
The return-a-string APIs come from here

https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Syntax%2BStringInterpolation.swift
-->


<!-- OUTLINE:

- Note:
  Behind the scenes, Swift serializes and deserializes the AST,
  to pass the data across process boundaries,
  but your macro implementation doesn't need to deal with any of that.

- This method is also passed a macro-expansion context, which you use to:

    + Generate unique symbol names
    + Produce diagnostics (`Diagnostic` and `SimpleDiagnosticMessage`)
    + Find a node's location in source

- Macro expansion happens in their surrounding context.
  A macro can affect that environment if it needs to ---
  and a macro that has bugs can interfere with that environment.
  (Give guidance on when you'd do this.  It should be rare.)

- Generated symbol names let a macro
  avoid accidentally interacting with symbols in that environment.
  To generate a unique symbol name,
  call the `MacroExpansionContext.makeUniqueName()` method.

- Ways to create a syntax node include
  Making an instance of the `Syntax` struct,
  or `SyntaxToken`
  or `ExprSyntax`.
  (Need to give folks some general ideas,
  and enough guidance so they can sort through
  all the various `SwiftSyntax` node types and find the right one.)

- Attached macros follow the same general model as expression macros,
  but with more moving parts.

- Pick the subprotocol of `AttachedMacro` to conform to,
  depending on which kind of attached macro you're making.
  [This is probably a table]

  + `AccessorMacro` goes with `@attached(accessor)`
  + `ConformanceMacro` goes with `@attached(conformance)`
    [missing from the list under Declaring a Macro]
  + `MemberMacro` goes with `@attached(member)`
  + `PeerMacro` goes with `@attached(peer)`
  + `MemberAttributeMacro` goes with `@member(memberAttribute)`

- Code example of conforming to `MemberMacro`.

  ```
  static func expansion<
    Declaration: DeclGroupSyntax,
    Context: MacroExpansionContext
  >(
    of node: AttributeSyntax,
    providingMembersOf declaration: Declaration,
    in context: Context
  ) throws -> [DeclSyntax]
  ```

- Adding a new member by making an instance of `Declaration`,
  and returning it as part of the `[DeclSyntax]` list.

-->

## Developing and Debugging Macros

Macros are well suited to development using tests:
They transform one AST into another AST
without depending on any external state,
and without making changes to any external state.
In addition, you can create syntax nodes from a string literal,
which simplifies setting up the input for a test.
You can also read the `description` property of an AST
to get a string to compare against an expected value.
For example,
here's a test of the `#fourCharacterCode` macro from previous sections:

```swift
let source: SourceFileSyntax =
    """
    let abcd = #fourCharacterCode("ABCD")
    """

let file = BasicMacroExpansionContext.KnownSourceFile(
    moduleName: "MyModule",
    fullFilePath: "test.swift"
)

let context = BasicMacroExpansionContext(sourceFiles: [source: file])

let transformedSF = source.expand(
    macros:["fourCharacterCode": FourCharacterCode.self],
    in: context
)

let expectedDescription =
    """
    let abcd = 1145258561 as UInt32
    """

precondition(transformedSF.description == expectedDescription)
```

The example above tests the macro using a precondition,
but you could use a testing framework instead.

<!-- OUTLINE:

- Ways to view the macro expansion while debugging.
  The SE prototype provides `-Xfrontend -dump-macro-expansions` for this.
  [TR: Is this flag what we should suggest folks use,
  or will there be better command-line options coming?]

- Use diagnostics for macros that have constraints/requirements
  so your code can give a meaningful error to users when those aren't met,
  instead of letting the compiler try & fail to build the generated code.

Additional APIs and concepts to introduce in the future,
in no particular order:

- Using `SyntaxRewriter` and the visitor pattern for modifying the AST

- Adding a suggested correction using `FixIt`

- concept of trivia

- `TokenSyntax`
-->

> Beta Software:
>
> This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
>
> Learn more about using [Apple's beta software](https://developer.apple.com/support/beta-software/).

<!--
This source file is part of the Swift.org open source project

Copyright (c) 2014 - 2023 Apple Inc. and the Swift project authors
Licensed under Apache License v2.0 with Runtime Library Exception

See https://swift.org/LICENSE.txt for license information
See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
-->


# 宏

通过使用宏在编译时生成代码。

宏在编译时会转换源代码，帮助您避免手动编写重复代码。
在编译过程中，Swift 会在正常构建代码之前扩展代码中的所有宏。

![一个显示宏扩展概述的图表。左侧是 Swift 代码的风格化表示，右侧是同样的代码，宏添加了几行。](macro-expansion)

扩展宏始终是一个附加操作：
宏添加新代码，但永远不会删除或修改现有代码。

宏的输入和宏扩展的输出都会被检查，以确保它们是语法上有效的 Swift 代码。
同样，您传递给宏的值和宏生成的代码中的值也会被检查，以确保它们具有正确的类型。
此外，如果在扩展宏时遇到错误，编译器会将其视为编译错误。
这些保证使得理解使用宏的代码变得更容易，并且使得识别诸如错误使用宏或宏实现存在错误等问题变得更容易。

Swift 有两种类型的宏：

- *独立宏*是指不附加到任何声明上的宏。

- *附加宏*修改它们附加到的声明。

您调用附加宏和独立宏的方式略有不同，但它们都遵循相同的宏扩展模型，并且您使用相同的方法实现它们。
以下部分将更详细地描述这两种宏。

## 独立宏

要调用独立宏，您在其名称前写一个井号（`#`），并在其名称后用括号写任何参数。
例如：

```swift
func myFunction() {
    print("当前运行 \(#function)")
    #warning("出现问题")
}
```

在第一行中，`#function` 调用 Swift 标准库中的 [`function()`][] 宏。
当您编译此代码时，Swift 调用该宏的实现，将 `#function` 替换为当前函数的名称。
当您运行此代码并调用 `myFunction()` 时，它打印 "当前运行 myFunction()"。
在第二行中，`#warning` 调用 Swift 标准库中的 [`warning(_:)`][] 宏以生成自定义的编译时警告。

[`function()`]: https://developer.apple.com/documentation/swift/function() [`warning(_:)`]: https://developer.apple.com/documentation/swift/warning(_:)

独立宏可以生成一个值，就像 `#function` 所做的那样，或者它们可以在编译时执行一个操作，就像 `#warning` 所做的那样。
<!-- SE-0397: 或者它们可以生成新的声明。 -->

## 附加宏

要调用附加宏，您在其名称前写一个 @ 符号（`@`），并在其名称后用括号写任何参数。

附加宏修改它们附加到的声明。
它们向该声明添加代码，例如定义一个新方法或添加对协议的遵循。

例如，考虑以下不使用宏的代码：

```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

在这段代码中，`SundaeToppings` 选项集中的每个选项都包含对初始化器的调用，这样是重复且手动的。
在添加新选项时，容易出现错误，例如在行末输入错误的数字。

这是使用宏的代码版本：

```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

这个版本的 `SundaeToppings` 调用了 `@OptionSet` 宏。
该宏读取私有枚举中的案例列表，为每个选项生成常量列表，并添加对 [`OptionSet`][] 协议的遵循。

[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset

<!--
当 @OptionSet 宏返回时，将两个链接都改回：

[`@OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.macro [`OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.protocol -->

以下是 `@OptionSet` 宏的扩展版本。
您不需要编写这段代码。只有在您特别要求 Swift 显示宏的扩展时，您才会看到它。

```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue

    init() {
        self.rawValue = 0
    }

    init(rawValue: RawValue) {
        self.rawValue = rawValue
    }

    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}

extension SundaeToppings: OptionSet { }
```

所有在私有枚举之后的代码均由 `@OptionSet` 宏生成。
使用宏生成的 `SundaeToppings` 版本比手动编码的版本更易读和维护。

## 宏声明

在大多数 Swift 代码中，实现符号（如函数或类型）时通常不需要单独声明。
然而，对于宏，声明和实现是分开的。
宏的声明包含名称和所需参数。它还包括可以使用的位置以及生成的代码类型。

您可以使用 `macro` 关键字引入宏声明。
例如，以下是前面示例中使用的 `@OptionSet` 宏的一部分声明：

```swift
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

第一行指定了宏的名称及其参数——名称是 `OptionSet`，并且不接受任何参数。
第二行使用 Swift 标准库中的 [`externalMacro(module:type:)`][] 宏来告诉 Swift 宏的实现位置。
在这种情况下，`SwiftMacros` 模块包含一个名为 `OptionSetMacro` 的类型，该类型实现了 `@OptionSet` 宏。

[`externalMacro(module:type:)`]: https://developer.apple.com/documentation/swift/externalmacro(module:type:)

因为 `OptionSet` 是一个附加宏，所以它的名称使用大驼峰命名法，类似于结构体和类的名称。
独立宏使用小驼峰命名法，类似于变量和函数的名称。

> 注意：
> 宏总是声明为 `public`。
> 因为声明宏的代码与使用该宏的代码在不同的模块中，所以没有地方可以应用非公共宏。

宏声明定义了宏的 *角色*——可以调用该宏的源代码位置，以及宏可以生成的代码类型。
每个宏都有一个或多个角色，您可以将其作为宏声明开头属性的一部分进行编写。
以下是 `@OptionSet` 声明的更多内容，包括其角色的属性：

```swift
@attached(member)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

`@attached` 属性在此声明中出现了两次，分别对应每个宏角色。
第一次使用 `@attached(member)`，表示宏向您应用的类型添加新成员。
`@OptionSet` 宏添加了 `OptionSet` 协议所需的 `init(rawValue:)` 初始化器，以及一些附加成员。
第二次使用 `@attached(extension, conformances: OptionSet)`，告诉您 `@OptionSet` 添加了对 `OptionSet` 协议的符合。
`@OptionSet` 宏扩展了您应用宏的类型，以添加对 `OptionSet` 协议的符合。

对于独立宏，您可以编写 `@freestanding` 属性来指定其角色：

```swift
@freestanding(expression)
public macro line<T: ExpressibleByIntegerLiteral>() -> T = /* ... location of the macro implementation... */
```

上面的 `#line` 宏具有 `expression` 角色。
表达式宏生成一个值，或执行编译时操作，如生成警告。

除了宏的角色，宏的声明还提供了生成符号名称的信息。

如果宏声明提供名称列表，它将只生成使用这些名称的声明，这有助于您理解和调试生成的代码。

以下是 `@OptionSet` 的完整声明：

```swift
@attached(member, names: named(RawValue), named(rawValue), named(`init`), arbitrary)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

在上面的声明中，`@attached(member)` 宏包含了每个符号的参数名称列表。这个列表位于 `names:` 标签之后。

该宏为名为 `RawValue`、`rawValue` 和 `init` 的符号添加了声明——因为这些名称是提前已知的，所以宏声明明确列出了它们。

宏声明在名称列表后还包含了 `arbitrary`。这允许宏生成在使用之前未知的名称声明。

例如，当 `@OptionSet` 宏应用于上面的 `SundaeToppings` 时，它生成与枚举案例 `nuts`、`cherry` 和 `fudge` 对应的类型属性。

有关更多信息，包括宏角色的完整列表，请参见 <doc:Attributes#attached> 和 <doc:Attributes#freestanding> 在 <doc:Attributes> 中。

## 宏扩展

在构建使用宏的 Swift 代码时，编译器调用宏的实现来扩展它们。

![显示扩展宏的四个步骤的图表。输入是 Swift 源代码。这变成一棵树，表示代码的结构。宏实现向树中添加分支。结果是带有附加代码的 Swift 源代码。](macro-expansion-full)

具体来说，Swift 以以下方式扩展宏：

1. 编译器读取代码，创建语法的内存表示。

2. 编译器将内存表示的一部分发送到宏实现，宏实现扩展宏。

3. 编译器用扩展形式替换宏调用。

4. 编译器继续编译，使用扩展后的源代码。

为了详细说明具体步骤，请考虑以下内容：

```swift
let magicNumber = #fourCharacterCode("ABCD")
```

`#fourCharacterCode` 宏接受一个长度为四个字符的字符串，并返回一个对应于字符串中 ASCII 值组合在一起的无符号 32 位整数。

一些文件格式使用这样的整数来标识数据，因为它们紧凑但在调试器中仍然可读。

下面的 <doc:Macros#Implementing-a-Macro> 部分展示了如何实现这个宏。

要扩展上面代码中的宏，编译器读取 Swift 文件并创建该代码的内存表示，称为 *抽象语法树*，或 AST。

AST 使代码的结构显式化，这使得编写与该结构交互的代码变得更容易——例如编译器或宏实现。

以下是上面代码的 AST 表示，略微简化，省略了一些额外细节：

![一棵树状图，常量作为根元素。常量有一个名称，magic number，以及一个值。常量的值是一个宏调用。宏调用有一个名称，fourCharacterCode，以及参数。参数是一个字符串字面量，ABCD。](macro-ast-original)

上面的图表显示了这段代码的结构如何在内存中表示。

AST 中的每个元素对应源代码的一部分。

“常量声明”AST 元素下有两个子元素，表示常量声明的两个部分：其名称和其值。

“宏调用”元素有子元素，表示宏的名称和传递给宏的参数列表。

作为构建此 AST 的一部分，编译器检查源代码是否是有效的 Swift。

例如，`#fourCharacterCode` 接受一个参数，该参数必须是字符串。

如果您尝试传递一个整数参数，或者忘记在字符串字面量的末尾加上引号（`"`），您将在此过程的这一点上遇到错误。

编译器找到代码中调用宏的位置，并加载实现这些宏的外部二进制文件。

对于每个宏调用，编译器将部分 AST 传递给该宏的实现。

以下是该部分 AST 的表示：

![一棵树状图，宏调用作为根元素。宏调用有一个名称，fourCharacterCode，其参数是字符串字面量，ABCD。](macro-ast-input)

`#fourCharacterCode` 宏的实现读取这个部分 AST 作为其输入来扩展宏。宏的实现仅对接收到的部分 AST 进行操作，这意味着宏的扩展方式始终相同，无论其前后代码是什么。这一限制有助于使宏扩展更易于理解，并帮助您的代码更快构建，因为 Swift 可以避免扩展未更改的宏。

Swift 通过限制实现宏的代码，帮助宏作者避免意外读取其他输入：

- 传递给宏实现的 AST 仅包含表示宏的 AST 元素，而不包含任何前后代码。

- 宏实现运行在一个沙盒环境中，防止其访问文件系统或网络。

除了这些保护措施，宏的作者还负责不读取或修改宏输入之外的任何内容。例如，宏的扩展不得依赖于当前的时间。

`#fourCharacterCode` 的实现生成一个包含扩展代码的新 AST。以下是该代码返回给编译器的内容：

![一个树状图，包含类型为 UInt32 的整数字面量 1145258561。](macro-ast-output)

当编译器接收到这个扩展时，它用包含宏扩展的元素替换包含宏调用的 AST 元素。在宏扩展后，编译器再次检查以确保程序仍然是语法上有效的 Swift，并且所有类型都是正确的。这产生了一个可以像往常一样编译的最终 AST：

![一个树状图，常量作为根元素。常量有一个名称，magic number，以及一个值。常量的值是类型为 UInt32 的整数字面量 1145258561。](macro-ast-result)

这个 AST 对应于如下的 Swift 代码：

``` let magicNumber = 1145258561 as UInt32 ```

在这个例子中，输入源代码只有一个宏，但一个真实的程序可能有多个相同宏的实例和多个不同宏的调用。编译器一次扩展一个宏。

如果一个宏出现在另一个宏内部，外部宏会先被扩展——这允许外部宏在内部宏扩展之前对其进行修改。

<!-- 大纲

- TR: 嵌套是否有限制？
  TR: 这样嵌套是否有效——如果是，有什么需要注意的？

  ``` let something = #someMacro { struct A { } @someMacro struct B { } } ```

- 宏递归是有限制的。
  一个宏可以调用另一个宏，但给定的宏不能直接或间接地调用自身。
  宏扩展的结果可以包含其他宏，但不能包含在其扩展中使用此宏的宏或声明新宏。
  (TR: 可能需要在这里迭代细节) -->

## 实现宏

要实现一个宏，您需要创建两个组件：
一个执行宏扩展的类型，以及一个声明宏以将其作为 API 暴露的库。这些部分与使用宏的代码分开构建，即使您同时开发宏及其客户端，因为宏实现作为构建宏客户端的一部分运行。

要使用 Swift Package Manager 创建一个新宏，请运行 `swift package init --type macro` ——这将创建多个文件，包括宏实现和声明的模板。

要将宏添加到现有项目中，请按如下方式编辑 `Package.swift` 文件的开头：

- 在 `swift-tools-version` 注释中设置 Swift 工具版本为 5.9 或更高。
- 导入 `CompilerPluginSupport` 模块。
- 在 `platforms` 列表中将 macOS 10.15 包含为最低部署目标。

下面的代码显示了一个示例 `Package.swift` 文件的开头。

```swift // swift-tools-version: 5.9

import PackageDescription
import CompilerPluginSupport

let package = Package(
    name: "MyPackage",
    platforms: [ .iOS(.v17), .macOS(.v13)],
    // ...
) ```

接下来，向现有的 `Package.swift` 文件添加一个宏实现的目标和一个宏库的目标。例如，您可以添加如下内容，修改名称以匹配您的项目：

```swift targets: [ // 宏实现，进行源代码转换。
    .macro( name: "MyProjectMacros", dependencies: [ .product(name: "SwiftSyntaxMacros", package: "swift-syntax"), .product(name: "SwiftCompilerPlugin", package: "swift-syntax") ] ),

    // 作为其 API 一部分公开宏的库。
    .target(name: "MyProject", dependencies: ["MyProjectMacros"]), ] ```

上面的代码定义了两个目标：
`MyProjectMacros` 实现了宏，而 `MyProject` 使这些宏可用。

宏的实现使用 [SwiftSyntax][] 模块与 Swift 代码进行结构化交互。它使用抽象语法树（AST）。
使用 Swift 包管理器创建新宏包时，生成的 `Package.swift` 文件会自动包含对 SwiftSyntax 的依赖。
要将宏添加到现有项目，请在 `Package.swift` 文件中添加对 SwiftSyntax 的依赖：

[SwiftSyntax]: http://github.com/apple/swift-syntax/

```swift dependencies: [ .package(url: "https://github.com/apple/swift-syntax", from: "509.0.0") ], ```

根据宏的角色，有相应的 SwiftSyntax 协议，宏实现需遵循该协议。
例如，考虑上一节中的 `#fourCharacterCode`。
以下是实现该宏的结构：

```swift import SwiftSyntax import SwiftSyntaxMacros

public struct FourCharacterCode: ExpressionMacro { public static func expansion( of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext ) throws -> ExprSyntax { guard let argument = node.argumentList.first?.expression, let segments = argument.as(StringLiteralExprSyntax.self)?.segments, segments.count == 1, case .stringSegment(let literalSegment)? = segments.first else { throw CustomError.message("需要一个静态字符串") }

        let string = literalSegment.content.text guard let result = fourCharacterCode(for: string) else { throw CustomError.message("无效的四字符代码") }

        return "\(raw: result) as UInt32" } }

private func fourCharacterCode(for characters: String) -> UInt32? { guard characters.count == 4 else { return nil }

    var result: UInt32 = 0 for character in characters { result = result << 8 guard let asciiValue = character.asciiValue else { return nil } result += UInt32(asciiValue) } return result } enum CustomError: Error { case message(String) } ```

将此宏添加到现有 Swift 包管理器项目时，请添加一个类型作为宏目标的入口点，并列出该目标定义的宏：

```swift import SwiftCompilerPlugin

@main struct MyProjectMacros: CompilerPlugin { var providingMacros: [Macro.Type] = [FourCharacterCode.self] } ```

`#fourCharacterCode` 宏是一个独立的宏，生成一个表达式，因此实现它的 `FourCharacterCode` 类型遵循 `ExpressionMacro` 协议。
`ExpressionMacro` 协议有一个要求，即 `expansion(of:in:)` 方法，用于扩展 AST。
有关宏角色及其相应的 SwiftSyntax 协议的列表，请参见 <doc:Attributes#attached> 和 <doc:Attributes#freestanding> 在 <doc:Attributes> 中。

要扩展 `#fourCharacterCode` 宏，
Swift 将使用此宏的代码的 AST 发送到包含宏实现的库。
在库内部，Swift 调用 `FourCharacterCode.expansion(of:in:)`，将 AST 和上下文作为参数传递给该方法。
`expansion(of:in:)` 的实现找到作为参数传递给 `#fourCharacterCode` 的字符串，并计算相应的 32 位无符号整数字面值。

在上面的示例中，第一个 `guard` 块从 AST 中提取字符串字面量，将该 AST 元素分配给 `literalSegment`。
第二个 `guard` 块调用私有的 `fourCharacterCode(for:)` 函数。
如果宏使用不当，这两个块都会抛出错误，错误消息会在格式错误的调用位置显示为编译器错误。
例如，如果您尝试将宏调用为 `#fourCharacterCode("AB" + "CD")`，编译器会显示错误 "需要一个静态字符串"。


`expansion(of:in:)` 方法返回一个 `ExprSyntax` 实例，这是来自 SwiftSyntax 的一个类型，表示抽象语法树（AST）中的一个表达式。
由于该类型符合 `StringLiteralConvertible` 协议，因此宏实现使用字符串字面量作为轻量级语法来创建其结果。
您从宏实现返回的所有 SwiftSyntax 类型都符合 `StringLiteralConvertible`，因此在实现任何类型的宏时都可以使用这种方法。

<!-- TODO 对比 `\(raw:)` 和非原始版本。 -->

<!--
返回字符串的 API 来源于这里

https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Syntax%2BStringInterpolation.swift -->


<!-- 大纲：

- 注意：
  在幕后，Swift 序列化和反序列化抽象语法树（AST），以便在进程边界之间传递数据，但您的宏实现不需要处理任何这些。

- 此方法还传递了一个宏扩展上下文，您可以用它来：

    + 生成唯一的符号名称 + 生成诊断信息（`Diagnostic` 和 `SimpleDiagnosticMessage`） + 查找节点在源代码中的位置

- 宏扩展发生在其周围的上下文中。
  如果需要，宏可以影响该环境——而且有缺陷的宏可能会干扰该环境。
  （提供关于何时这样做的指导。这应该是罕见的。）

- 生成的符号名称使宏能够避免意外与该环境中的符号交互。
  要生成唯一的符号名称，请调用 `MacroExpansionContext.makeUniqueName()` 方法。

- 创建语法节点的方式包括创建 `Syntax` 结构的实例，或 `SyntaxToken` 或 `ExprSyntax`。
  需要给大家一些一般性的想法，以及足够的指导，以便他们能够理清所有各种 `SwiftSyntax` 节点类型并找到合适的。

- 附加宏遵循与表达式宏相同的一般模型，但有更多的活动部分。

- 根据您正在制作的附加宏的类型，选择符合的 `AttachedMacro` 子协议。
  [这可能是一个表格]

  + `AccessorMacro` 与 `@attached(accessor)` 一起使用 + `ConformanceMacro` 与 `@attached(conformance)` 一起使用 [在声明宏的列表中缺失] + `MemberMacro` 与 `@attached(member)` 一起使用 + `PeerMacro` 与 `@attached(peer)` 一起使用 + `MemberAttributeMacro` 与 `@member(memberAttribute)` 一起使用

- 符合 `MemberMacro` 的代码示例。

  ``` static func expansion< Declaration: DeclGroupSyntax, Context: MacroExpansionContext >( of node: AttributeSyntax, providingMembersOf declaration: Declaration, in context: Context ) throws -> [DeclSyntax] ```

- 通过创建 `Declaration` 的实例来添加新成员，并将其作为 `[DeclSyntax]` 列表的一部分返回。

-->

## 开发和调试宏

宏非常适合使用测试进行开发：
它们将一个抽象语法树（AST）转换为另一个抽象语法树，而不依赖于任何外部状态，也不对任何外部状态进行更改。
此外，您可以从字符串字面量创建语法节点，这简化了测试输入的设置。
您还可以读取抽象语法树（AST）的 `description` 属性，以获取一个字符串与预期值进行比较。
例如，这是对前面部分中 `#fourCharacterCode` 宏的测试：

```swift
let source: SourceFileSyntax = """ let abcd = #fourCharacterCode("ABCD") """

let file = BasicMacroExpansionContext.KnownSourceFile( moduleName: "MyModule", fullFilePath: "test.swift" )

let context = BasicMacroExpansionContext(sourceFiles: [source: file])

let transformedSF = source.expand( macros:["fourCharacterCode": FourCharacterCode.self], in: context )

let expectedDescription = """ let abcd = 1145258561 as UInt32 """

precondition(transformedSF.description == expectedDescription) ```

上面的示例使用前提条件测试宏，但您也可以使用测试框架。

<!-- 大纲：

- 调试时查看宏扩展的方法。
  SE 原型提供了 `-Xfrontend -dump-macro-expansions` 用于此。
  [TR：这个标志是我们应该建议大家使用的吗，还是会有更好的命令行选项？]

- 对于具有约束/要求的宏，使用诊断信息，以便您的代码可以在未满足这些要求时向用户提供有意义的错误，而不是让编译器尝试并失败构建生成的代码。

未来要介绍的其他 API 和概念，顺序不分：

- 使用 `SyntaxRewriter` 和访问者模式修改抽象语法树（AST）

- 使用 `FixIt` 添加建议的修正

- 通过 `FixIt` 添加建议的修正

- 琐事的概念

- `TokenSyntax` -->

> 测试版软件：
> > 本文档包含有关正在开发的 API 或技术的初步信息。这些信息可能会发生变化，按照本文件中的说明实现的软件应与最终操作系统软件进行测试。
> > 了解有关使用 [Apple 的测试版软件](https://developer.apple.com/support/beta-software/) 的更多信息。

<!--
此源文件是 Swift.org 开源项目的一部分

版权所有 (c) 2014 - 2023 Apple Inc. 和 Swift 项目作者
根据 Apache 许可证 v2.0 及运行时库例外授权

有关许可证信息，请参见 https://swift.org/LICENSE.txt
有关 Swift 项目作者的列表，请参见 https://swift.org/CONTRIBUTORS.txt -->
==================================================
2024-08-06 22:17:27,647 - INFO - Final processed text:
==================================================
# 宏

通过使用宏在编译时生成代码。

宏在编译时会转换源代码，帮助您避免手动编写重复代码。
在编译过程中，Swift 会在正常构建代码之前扩展代码中的所有宏。

![一个显示宏扩展概述的图表。左侧是 Swift 代码的风格化表示，右侧是同样的代码，宏添加了几行。](macro-expansion)

扩展宏始终是一个附加操作：
宏添加新代码，但永远不会删除或修改现有代码。

宏的输入和宏扩展的输出都会被检查，以确保它们是语法上有效的 Swift 代码。
同样，您传递给宏的值和宏生成的代码中的值也会被检查，以确保它们具有正确的类型。
此外，如果在扩展宏时遇到错误，编译器会将其视为编译错误。
这些保证使得理解使用宏的代码变得更容易，并且使得识别诸如错误使用宏或宏实现存在错误等问题变得更容易。

Swift 有两种类型的宏：

- *独立宏*是指不附加到任何声明上的宏。

- *附加宏*修改它们附加到的声明。

您调用附加宏和独立宏的方式略有不同，但它们都遵循相同的宏扩展模型，并且您使用相同的方法实现它们。
以下部分将更详细地描述这两种宏。

## 独立宏

要调用独立宏，您在其名称前写一个井号（`#`），并在其名称后用括号写任何参数。
例如：

```swift
func myFunction() {
    print("当前运行 \(#function)")
    #warning("出现问题")
}
```

在第一行中，`#function` 调用 Swift 标准库中的 [`function()`][] 宏。
当您编译此代码时，Swift 调用该宏的实现，将 `#function` 替换为当前函数的名称。
当您运行此代码并调用 `myFunction()` 时，它打印 "当前运行 myFunction()"。
在第二行中，`#warning` 调用 Swift 标准库中的 [`warning(_:)`][] 宏以生成自定义的编译时警告。

[`function()`]: https://developer.apple.com/documentation/swift/function() [`warning(_:)`]: https://developer.apple.com/documentation/swift/warning(_:)

独立宏可以生成一个值，就像 `#function` 所做的那样，或者它们可以在编译时执行一个操作，就像 `#warning` 所做的那样。
<!-- SE-0397: 或者它们可以生成新的声明。 -->

## 附加宏

要调用附加宏，您在其名称前写一个 @ 符号（`@`），并在其名称后用括号写任何参数。

附加宏修改它们附加到的声明。
它们向该声明添加代码，例如定义一个新方法或添加对协议的遵循。

例如，考虑以下不使用宏的代码：

```swift
struct SundaeToppings: OptionSet {
    let rawValue: Int
    static let nuts = SundaeToppings(rawValue: 1 << 0)
    static let cherry = SundaeToppings(rawValue: 1 << 1)
    static let fudge = SundaeToppings(rawValue: 1 << 2)
}
```

在这段代码中，`SundaeToppings` 选项集中的每个选项都包含对初始化器的调用，这样是重复且手动的。
在添加新选项时，容易出现错误，例如在行末输入错误的数字。

这是使用宏的代码版本：

```swift
@OptionSet<Int>
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }
}
```

这个版本的 `SundaeToppings` 调用了 `@OptionSet` 宏。
该宏读取私有枚举中的案例列表，为每个选项生成常量列表，并添加对 [`OptionSet`][] 协议的遵循。

[`OptionSet`]: https://developer.apple.com/documentation/swift/optionset

<!--
当 @OptionSet 宏返回时，将两个链接都改回：

[`@OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.macro [`OptionSet`]: https://developer.apple.com/documentation/swift/optionset-swift.protocol -->

以下是 `@OptionSet` 宏的扩展版本。
您不需要编写这段代码。只有在您特别要求 Swift 显示宏的扩展时，您才会看到它。

```swift
struct SundaeToppings {
    private enum Options: Int {
        case nuts
        case cherry
        case fudge
    }

    typealias RawValue = Int
    var rawValue: RawValue

    init() {
        self.rawValue = 0
    }

    init(rawValue: RawValue) {
        self.rawValue = rawValue
    }

    static let nuts: Self = Self(rawValue: 1 << Options.nuts.rawValue)
    static let cherry: Self = Self(rawValue: 1 << Options.cherry.rawValue)
    static let fudge: Self = Self(rawValue: 1 << Options.fudge.rawValue)
}

extension SundaeToppings: OptionSet { }
```

所有在私有枚举之后的代码均由 `@OptionSet` 宏生成。
使用宏生成的 `SundaeToppings` 版本比手动编码的版本更易读和维护。

## 宏声明

在大多数 Swift 代码中，实现符号（如函数或类型）时通常不需要单独声明。
然而，对于宏，声明和实现是分开的。
宏的声明包含名称和所需参数。它还包括可以使用的位置以及生成的代码类型。

您可以使用 `macro` 关键字引入宏声明。
例如，以下是前面示例中使用的 `@OptionSet` 宏的一部分声明：

```swift
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

第一行指定了宏的名称及其参数——名称是 `OptionSet`，并且不接受任何参数。
第二行使用 Swift 标准库中的 [`externalMacro(module:type:)`][] 宏来告诉 Swift 宏的实现位置。
在这种情况下，`SwiftMacros` 模块包含一个名为 `OptionSetMacro` 的类型，该类型实现了 `@OptionSet` 宏。

[`externalMacro(module:type:)`]: https://developer.apple.com/documentation/swift/externalmacro(module:type:)

因为 `OptionSet` 是一个附加宏，所以它的名称使用大驼峰命名法，类似于结构体和类的名称。
独立宏使用小驼峰命名法，类似于变量和函数的名称。

> 注意：
> 宏总是声明为 `public`。
> 因为声明宏的代码与使用该宏的代码在不同的模块中，所以没有地方可以应用非公共宏。

宏声明定义了宏的 *角色*——可以调用该宏的源代码位置，以及宏可以生成的代码类型。
每个宏都有一个或多个角色，您可以将其作为宏声明开头属性的一部分进行编写。
以下是 `@OptionSet` 声明的更多内容，包括其角色的属性：

```swift
@attached(member)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

`@attached` 属性在此声明中出现了两次，分别对应每个宏角色。
第一次使用 `@attached(member)`，表示宏向您应用的类型添加新成员。
`@OptionSet` 宏添加了 `OptionSet` 协议所需的 `init(rawValue:)` 初始化器，以及一些附加成员。
第二次使用 `@attached(extension, conformances: OptionSet)`，告诉您 `@OptionSet` 添加了对 `OptionSet` 协议的符合。
`@OptionSet` 宏扩展了您应用宏的类型，以添加对 `OptionSet` 协议的符合。

对于独立宏，您可以编写 `@freestanding` 属性来指定其角色：

```swift
@freestanding(expression)
public macro line<T: ExpressibleByIntegerLiteral>() -> T = /* ... location of the macro implementation... */
```

上面的 `#line` 宏具有 `expression` 角色。
表达式宏生成一个值，或执行编译时操作，如生成警告。

除了宏的角色，宏的声明还提供了生成符号名称的信息。

如果宏声明提供名称列表，它将只生成使用这些名称的声明，这有助于您理解和调试生成的代码。

以下是 `@OptionSet` 的完整声明：

```swift
@attached(member, names: named(RawValue), named(rawValue), named(`init`), arbitrary)
@attached(extension, conformances: OptionSet)
public macro OptionSet<RawType>() = #externalMacro(module: "SwiftMacros", type: "OptionSetMacro")
```

在上面的声明中，`@attached(member)` 宏包含了每个符号的参数名称列表。这个列表位于 `names:` 标签之后。

该宏为名为 `RawValue`、`rawValue` 和 `init` 的符号添加了声明——因为这些名称是提前已知的，所以宏声明明确列出了它们。

宏声明在名称列表后还包含了 `arbitrary`。这允许宏生成在使用之前未知的名称声明。

例如，当 `@OptionSet` 宏应用于上面的 `SundaeToppings` 时，它生成与枚举案例 `nuts`、`cherry` 和 `fudge` 对应的类型属性。

有关更多信息，包括宏角色的完整列表，请参见 <doc:Attributes#attached> 和 <doc:Attributes#freestanding> 在 <doc:Attributes> 中。

## 宏扩展

在构建使用宏的 Swift 代码时，编译器调用宏的实现来扩展它们。

![显示扩展宏的四个步骤的图表。输入是 Swift 源代码。这变成一棵树，表示代码的结构。宏实现向树中添加分支。结果是带有附加代码的 Swift 源代码。](macro-expansion-full)

具体来说，Swift 以以下方式扩展宏：

1. 编译器读取代码，创建语法的内存表示。

2. 编译器将内存表示的一部分发送到宏实现，宏实现扩展宏。

3. 编译器用扩展形式替换宏调用。

4. 编译器继续编译，使用扩展后的源代码。

为了详细说明具体步骤，请考虑以下内容：

```swift
let magicNumber = #fourCharacterCode("ABCD")
```

`#fourCharacterCode` 宏接受一个长度为四个字符的字符串，并返回一个对应于字符串中 ASCII 值组合在一起的无符号 32 位整数。

一些文件格式使用这样的整数来标识数据，因为它们紧凑但在调试器中仍然可读。

下面的 <doc:Macros#Implementing-a-Macro> 部分展示了如何实现这个宏。

要扩展上面代码中的宏，编译器读取 Swift 文件并创建该代码的内存表示，称为 *抽象语法树*，或 AST。

AST 使代码的结构显式化，这使得编写与该结构交互的代码变得更容易——例如编译器或宏实现。

以下是上面代码的 AST 表示，略微简化，省略了一些额外细节：

![一棵树状图，常量作为根元素。常量有一个名称，magic number，以及一个值。常量的值是一个宏调用。宏调用有一个名称，fourCharacterCode，以及参数。参数是一个字符串字面量，ABCD。](macro-ast-original)

上面的图表显示了这段代码的结构如何在内存中表示。

AST 中的每个元素对应源代码的一部分。

“常量声明”AST 元素下有两个子元素，表示常量声明的两个部分：其名称和其值。

“宏调用”元素有子元素，表示宏的名称和传递给宏的参数列表。

作为构建此 AST 的一部分，编译器检查源代码是否是有效的 Swift。

例如，`#fourCharacterCode` 接受一个参数，该参数必须是字符串。

如果您尝试传递一个整数参数，或者忘记在字符串字面量的末尾加上引号（`"`），您将在此过程的这一点上遇到错误。

编译器找到代码中调用宏的位置，并加载实现这些宏的外部二进制文件。

对于每个宏调用，编译器将部分 AST 传递给该宏的实现。

以下是该部分 AST 的表示：

![一棵树状图，宏调用作为根元素。宏调用有一个名称，fourCharacterCode，其参数是字符串字面量，ABCD。](macro-ast-input)

`#fourCharacterCode` 宏的实现读取这个部分 AST 作为其输入来扩展宏。宏的实现仅对接收到的部分 AST 进行操作，这意味着宏的扩展方式始终相同，无论其前后代码是什么。这一限制有助于使宏扩展更易于理解，并帮助您的代码更快构建，因为 Swift 可以避免扩展未更改的宏。

Swift 通过限制实现宏的代码，帮助宏作者避免意外读取其他输入：

- 传递给宏实现的 AST 仅包含表示宏的 AST 元素，而不包含任何前后代码。

- 宏实现运行在一个沙盒环境中，防止其访问文件系统或网络。

除了这些保护措施，宏的作者还负责不读取或修改宏输入之外的任何内容。例如，宏的扩展不得依赖于当前的时间。

`#fourCharacterCode` 的实现生成一个包含扩展代码的新 AST。以下是该代码返回给编译器的内容：

![一个树状图，包含类型为 UInt32 的整数字面量 1145258561。](macro-ast-output)

当编译器接收到这个扩展时，它用包含宏扩展的元素替换包含宏调用的 AST 元素。在宏扩展后，编译器再次检查以确保程序仍然是语法上有效的 Swift，并且所有类型都是正确的。这产生了一个可以像往常一样编译的最终 AST：

![一个树状图，常量作为根元素。常量有一个名称，magic number，以及一个值。常量的值是类型为 UInt32 的整数字面量 1145258561。](macro-ast-result)

这个 AST 对应于如下的 Swift 代码：

``` let magicNumber = 1145258561 as UInt32 ```

在这个例子中，输入源代码只有一个宏，但一个真实的程序可能有多个相同宏的实例和多个不同宏的调用。编译器一次扩展一个宏。

如果一个宏出现在另一个宏内部，外部宏会先被扩展——这允许外部宏在内部宏扩展之前对其进行修改。

<!-- 大纲

- TR: 嵌套是否有限制？
  TR: 这样嵌套是否有效——如果是，有什么需要注意的？

  ``` let something = #someMacro { struct A { } @someMacro struct B { } } ```

- 宏递归是有限制的。
  一个宏可以调用另一个宏，但给定的宏不能直接或间接地调用自身。
  宏扩展的结果可以包含其他宏，但不能包含在其扩展中使用此宏的宏或声明新宏。
  (TR: 可能需要在这里迭代细节) -->

## 实现宏

要实现一个宏，您需要创建两个组件：
一个执行宏扩展的类型，以及一个声明宏以将其作为 API 暴露的库。这些部分与使用宏的代码分开构建，即使您同时开发宏及其客户端，因为宏实现作为构建宏客户端的一部分运行。

要使用 Swift Package Manager 创建一个新宏，请运行 `swift package init --type macro` ——这将创建多个文件，包括宏实现和声明的模板。

要将宏添加到现有项目中，请按如下方式编辑 `Package.swift` 文件的开头：

- 在 `swift-tools-version` 注释中设置 Swift 工具版本为 5.9 或更高。
- 导入 `CompilerPluginSupport` 模块。
- 在 `platforms` 列表中将 macOS 10.15 包含为最低部署目标。

下面的代码显示了一个示例 `Package.swift` 文件的开头。

```swift // swift-tools-version: 5.9

import PackageDescription
import CompilerPluginSupport

let package = Package(
    name: "MyPackage",
    platforms: [ .iOS(.v17), .macOS(.v13)],
    // ...
) ```

接下来，向现有的 `Package.swift` 文件添加一个宏实现的目标和一个宏库的目标。例如，您可以添加如下内容，修改名称以匹配您的项目：

```swift targets: [ // 宏实现，进行源代码转换。
    .macro( name: "MyProjectMacros", dependencies: [ .product(name: "SwiftSyntaxMacros", package: "swift-syntax"), .product(name: "SwiftCompilerPlugin", package: "swift-syntax") ] ),

    // 作为其 API 一部分公开宏的库。
    .target(name: "MyProject", dependencies: ["MyProjectMacros"]), ] ```

上面的代码定义了两个目标：
`MyProjectMacros` 实现了宏，而 `MyProject` 使这些宏可用。

宏的实现使用 [SwiftSyntax][] 模块与 Swift 代码进行结构化交互。它使用抽象语法树（AST）。
使用 Swift 包管理器创建新宏包时，生成的 `Package.swift` 文件会自动包含对 SwiftSyntax 的依赖。
要将宏添加到现有项目，请在 `Package.swift` 文件中添加对 SwiftSyntax 的依赖：

[SwiftSyntax]: http://github.com/apple/swift-syntax/

```swift dependencies: [ .package(url: "https://github.com/apple/swift-syntax", from: "509.0.0") ], ```

根据宏的角色，有相应的 SwiftSyntax 协议，宏实现需遵循该协议。
例如，考虑上一节中的 `#fourCharacterCode`。
以下是实现该宏的结构：

```swift import SwiftSyntax import SwiftSyntaxMacros

public struct FourCharacterCode: ExpressionMacro { public static func expansion( of node: some FreestandingMacroExpansionSyntax, in context: some MacroExpansionContext ) throws -> ExprSyntax { guard let argument = node.argumentList.first?.expression, let segments = argument.as(StringLiteralExprSyntax.self)?.segments, segments.count == 1, case .stringSegment(let literalSegment)? = segments.first else { throw CustomError.message("需要一个静态字符串") }

        let string = literalSegment.content.text guard let result = fourCharacterCode(for: string) else { throw CustomError.message("无效的四字符代码") }

        return "\(raw: result) as UInt32" } }

private func fourCharacterCode(for characters: String) -> UInt32? { guard characters.count == 4 else { return nil }

    var result: UInt32 = 0 for character in characters { result = result << 8 guard let asciiValue = character.asciiValue else { return nil } result += UInt32(asciiValue) } return result } enum CustomError: Error { case message(String) } ```

将此宏添加到现有 Swift 包管理器项目时，请添加一个类型作为宏目标的入口点，并列出该目标定义的宏：

```swift import SwiftCompilerPlugin

@main struct MyProjectMacros: CompilerPlugin { var providingMacros: [Macro.Type] = [FourCharacterCode.self] } ```

`#fourCharacterCode` 宏是一个独立的宏，生成一个表达式，因此实现它的 `FourCharacterCode` 类型遵循 `ExpressionMacro` 协议。
`ExpressionMacro` 协议有一个要求，即 `expansion(of:in:)` 方法，用于扩展 AST。
有关宏角色及其相应的 SwiftSyntax 协议的列表，请参见 <doc:Attributes#attached> 和 <doc:Attributes#freestanding> 在 <doc:Attributes> 中。

要扩展 `#fourCharacterCode` 宏，
Swift 将使用此宏的代码的 AST 发送到包含宏实现的库。
在库内部，Swift 调用 `FourCharacterCode.expansion(of:in:)`，将 AST 和上下文作为参数传递给该方法。
`expansion(of:in:)` 的实现找到作为参数传递给 `#fourCharacterCode` 的字符串，并计算相应的 32 位无符号整数字面值。

在上面的示例中，第一个 `guard` 块从 AST 中提取字符串字面量，将该 AST 元素分配给 `literalSegment`。
第二个 `guard` 块调用私有的 `fourCharacterCode(for:)` 函数。
如果宏使用不当，这两个块都会抛出错误，错误消息会在格式错误的调用位置显示为编译器错误。
例如，如果您尝试将宏调用为 `#fourCharacterCode("AB" + "CD")`，编译器会显示错误 "需要一个静态字符串"。


`expansion(of:in:)` 方法返回一个 `ExprSyntax` 实例，这是来自 SwiftSyntax 的一个类型，表示抽象语法树（AST）中的一个表达式。
由于该类型符合 `StringLiteralConvertible` 协议，因此宏实现使用字符串字面量作为轻量级语法来创建其结果。
您从宏实现返回的所有 SwiftSyntax 类型都符合 `StringLiteralConvertible`，因此在实现任何类型的宏时都可以使用这种方法。

<!-- TODO 对比 `\(raw:)` 和非原始版本。 -->

<!--
返回字符串的 API 来源于这里

https://github.com/apple/swift-syntax/blob/main/Sources/SwiftSyntaxBuilder/Syntax%2BStringInterpolation.swift -->


<!-- 大纲：

- 注意：
  在幕后，Swift 序列化和反序列化抽象语法树（AST），以便在进程边界之间传递数据，但您的宏实现不需要处理任何这些。

- 此方法还传递了一个宏扩展上下文，您可以用它来：

    + 生成唯一的符号名称 + 生成诊断信息（`Diagnostic` 和 `SimpleDiagnosticMessage`） + 查找节点在源代码中的位置

- 宏扩展发生在其周围的上下文中。
  如果需要，宏可以影响该环境——而且有缺陷的宏可能会干扰该环境。
  （提供关于何时这样做的指导。这应该是罕见的。）

- 生成的符号名称使宏能够避免意外与该环境中的符号交互。
  要生成唯一的符号名称，请调用 `MacroExpansionContext.makeUniqueName()` 方法。

- 创建语法节点的方式包括创建 `Syntax` 结构的实例，或 `SyntaxToken` 或 `ExprSyntax`。
  需要给大家一些一般性的想法，以及足够的指导，以便他们能够理清所有各种 `SwiftSyntax` 节点类型并找到合适的。

- 附加宏遵循与表达式宏相同的一般模型，但有更多的活动部分。

- 根据您正在制作的附加宏的类型，选择符合的 `AttachedMacro` 子协议。
  [这可能是一个表格]

  + `AccessorMacro` 与 `@attached(accessor)` 一起使用 + `ConformanceMacro` 与 `@attached(conformance)` 一起使用 [在声明宏的列表中缺失] + `MemberMacro` 与 `@attached(member)` 一起使用 + `PeerMacro` 与 `@attached(peer)` 一起使用 + `MemberAttributeMacro` 与 `@member(memberAttribute)` 一起使用

- 符合 `MemberMacro` 的代码示例。

  ``` static func expansion< Declaration: DeclGroupSyntax, Context: MacroExpansionContext >( of node: AttributeSyntax, providingMembersOf declaration: Declaration, in context: Context ) throws -> [DeclSyntax] ```

- 通过创建 `Declaration` 的实例来添加新成员，并将其作为 `[DeclSyntax]` 列表的一部分返回。

-->

## 开发和调试宏

宏非常适合使用测试进行开发：
它们将一个抽象语法树（AST）转换为另一个抽象语法树，而不依赖于任何外部状态，也不对任何外部状态进行更改。
此外，您可以从字符串字面量创建语法节点，这简化了测试输入的设置。
您还可以读取抽象语法树（AST）的 `description` 属性，以获取一个字符串与预期值进行比较。
例如，这是对前面部分中 `#fourCharacterCode` 宏的测试：

```swift
let source: SourceFileSyntax = """ let abcd = #fourCharacterCode("ABCD") """

let file = BasicMacroExpansionContext.KnownSourceFile( moduleName: "MyModule", fullFilePath: "test.swift" )

let context = BasicMacroExpansionContext(sourceFiles: [source: file])

let transformedSF = source.expand( macros:["fourCharacterCode": FourCharacterCode.self], in: context )

let expectedDescription = """ let abcd = 1145258561 as UInt32 """

precondition(transformedSF.description == expectedDescription) ```

上面的示例使用前提条件测试宏，但您也可以使用测试框架。

<!-- 大纲：

- 调试时查看宏扩展的方法。
  SE 原型提供了 `-Xfrontend -dump-macro-expansions` 用于此。
  [TR：这个标志是我们应该建议大家使用的吗，还是会有更好的命令行选项？]

- 对于具有约束/要求的宏，使用诊断信息，以便您的代码可以在未满足这些要求时向用户提供有意义的错误，而不是让编译器尝试并失败构建生成的代码。

未来要介绍的其他 API 和概念，顺序不分：

- 使用 `SyntaxRewriter` 和访问者模式修改抽象语法树（AST）

- 使用 `FixIt` 添加建议的修正

- 通过 `FixIt` 添加建议的修正

- 琐事的概念

- `TokenSyntax` -->

> 测试版软件：
> > 本文档包含有关正在开发的 API 或技术的初步信息。这些信息可能会发生变化，按照本文件中的说明实现的软件应与最终操作系统软件进行测试。
> > 了解有关使用 [Apple 的测试版软件](https://developer.apple.com/support/beta-software/) 的更多信息。

<!--
此源文件是 Swift.org 开源项目的一部分

版权所有 (c) 2014 - 2023 Apple Inc. 和 Swift 项目作者
根据 Apache 许可证 v2.0 及运行时库例外授权

有关许可证信息，请参见 https://swift.org/LICENSE.txt
有关 Swift 项目作者的列表，请参见 https://swift.org/CONTRIBUTORS.txt -->